[{"title":"快速进行点群（图节点）对齐以及Kabsch算法的代码实现","path":"/2024/08/12/kabsch/","content":"本文介绍了Kabsch算法原理，并用多个框架对算法进行了代码实现。 Kabsch AlgorithmKabsch算法（又称Kabsch-Umeyama算法）是一种用于在两组对应点之间找到最佳刚体旋转的算法，目的是最小化两个点集之间的均方根误差（RMSD, Root Mean Square Deviation），该算法在分子模拟、图机器学习（or GNN）等领域中非常有用。 算法原理Kabsch算法的目标是给定两个质心相同的点集，找到一个旋转矩阵$R$来使得其中一个点集旋转后与另外一个点集之间的欧式距离最小。算法的核心思想是通过对点集进行去质心化和对协方差矩阵进行奇异值分解（SVD）来找到最佳的刚体旋转矩阵，从而最小化点集之间的距离。 注意前提是点群的点已经是一一对应的 假设有两个任意点集$P$和$Q$，$P \\in \\mathbb{R}^{N \\times D}$，$Q$的维度与$P$一致，其中$N$为节点的个数，$D$为节点特征的维度，例如分子的笛卡尔坐标的点集为$\\mathbb{R}^{N \\times 3}$。则Kabsch算法的目标为找到旋转矩阵$R$和平移向量$\\mathbf{t}$使得下式最小：$$\\min\\sum_{i&#x3D;1}^{N} \\left| \\mathbf{q}_i - \\mathbf{R} (\\mathbf{p}_i + \\mathbf{t}) \\right|^2$$ 除基本对齐的要求外，有需要也可以为点集中的点加入权重$\\omega$，这在许多问题中有重要作用。例如需要对大分子进行align，我们可以添加原子的相对原子质量作为权重，一定程度忽略H原子对结构对齐的影响，因为H原子很多情况下可以自由旋转，则优化目标可变为下式：$$\\min\\sum_{i&#x3D;1}^{N} \\omega_i \\left| \\mathbf{q}_i - \\mathbf{R} (\\mathbf{p}_i + \\mathbf{t}) \\right|^2$$ 去质心化（Centering the Point Sets） 首先计算点集$P$和$R$的质心：$$c_P &#x3D; \\frac{1}{N} \\sum_{i&#x3D;1}^{N} p_i$$ $$c_Q &#x3D; \\frac{1}{N} \\sum_{i&#x3D;1}^{N} q_i$$ 通过减去质心坐标，将两个点群平移到相同的质心。 $$P’ &#x3D; P - c_P$$ $$Q’ &#x3D; Q - c_Q$$ 计算协方差矩阵（Covariance Matrix）幷进行奇异值分解（SVD） 通过两个去质心化点群的外积求得点群之间的协方差矩阵$H$： $$H &#x3D; P’^TQ’&#x3D;\\sum_{i&#x3D;1}^{n} {p’_i}^T q’_i \\in \\mathbb{R}^{D \\times D}$$ 然后对$H$进行奇异值分解： $$H &#x3D; U \\Sigma V^T$$ 再由下式即可求得旋转矩阵$R$： $$R &#x3D; VU^T$$ 此处要注意若行列式的值$\\text{det}(VU^T)$为负数，则说明出现了$R$变换出现了反射（Reflection），因此需要对$V$最后一个奇异值进行修正，令$B&#x3D;\\text{diag}(1, 1, \\text{sign}(\\text{det}(VU^T)))$，修正后的旋转矩阵$R$如下： $$R &#x3D; VBU^T$$ 进行Align 计算平移向量$\\mathbf{t}$,即求两个质心之间的距离向量： $$\\mathbf{t} &#x3D; c_Q - c_P$$ $$P_{\\text{aligned}} &#x3D; P’ R$$ 然后可简单地求出RMSD： $$\\text{RMSD} &#x3D; \\sqrt{\\frac{1}{N}\\sum_{i&#x3D;1}^N\\left| q’i - p{align, i} \\right| ^ 2}$$ 代码实现代码基于Python的PyTorch框架实现，同时也提供了NumPy和JAX框架，以及Rust的实现代码。 PyTorch实现1234567891011121314151617181920212223242526272829303132333435363738394041import torchdef kabsch_torch(P, Q): &quot;&quot;&quot; Computes the optimal rotation and translation to align two sets of points (P -&gt; Q), and their RMSD. :param P: A Nx3 matrix of points :param Q: A Nx3 matrix of points :return: A tuple containing the optimal rotation matrix, the optimal translation vector, and the RMSD. &quot;&quot;&quot; assert P.shape == Q.shape, &quot;Matrix dimensions must match&quot; # Compute centroids centroid_P = torch.mean(P, dim=0) centroid_Q = torch.mean(Q, dim=0) # Optimal translation t = centroid_Q - centroid_P # Center the points p = P - centroid_P q = Q - centroid_Q # Compute the covariance matrix H = torch.matmul(p.transpose(0, 1), q) # SVD U, S, Vt = torch.linalg.svd(H) # Validate right-handed coordinate system if torch.det(torch.matmul(Vt.transpose(0, 1), U.transpose(0, 1))) &lt; 0.0: Vt[:, -1] *= -1.0 # Optimal rotation R = torch.matmul(Vt.transpose(0, 1), U.transpose(0, 1)) # RMSD rmsd = torch.sqrt(torch.sum(torch.square(torch.matmul(p, R.transpose(0, 1)) - q)) / P.shape[0]) return R, t, rmsd NumPy实现123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npdef kabsch_numpy(P, Q): &quot;&quot;&quot; Computes the optimal rotation and translation to align two sets of points (P -&gt; Q), and their RMSD. :param P: A Nx3 matrix of points :param Q: A Nx3 matrix of points :return: A tuple containing the optimal rotation matrix, the optimal translation vector, and the RMSD. &quot;&quot;&quot; assert P.shape == Q.shape, &quot;Matrix dimensions must match&quot; # Compute centroids centroid_P = np.mean(P, axis=0) centroid_Q = np.mean(Q, axis=0) # Optimal translation t = centroid_Q - centroid_P # Center the points p = P - centroid_P q = Q - centroid_Q # Compute the covariance matrix H = np.dot(p.T, q) # SVD U, S, Vt = np.linalg.svd(H) # Validate right-handed coordinate system if np.linalg.det(np.dot(Vt.T, U.T)) &lt; 0.0: Vt[-1, :] *= -1.0 # Optimal rotation R = np.dot(Vt.T, U.T) # RMSD rmsd = np.sqrt(np.sum(np.square(np.dot(p, R.T) - q)) / P.shape[0]) return R, t, rmsd JAX实现12345678910111213141516171819202122232425262728293031323334353637383940414243import jax.numpy as jnpdef kabsch_jax(P, Q): &quot;&quot;&quot; Computes the optimal rotation and translation to align two sets of points (P -&gt; Q), and their RMSD. :param P: A Nx3 matrix of points :param Q: A Nx3 matrix of points :return: A tuple containing the optimal rotation matrix, the optimal translation vector, and the RMSD. &quot;&quot;&quot; assert P.shape == Q.shape, &quot;Matrix dimensions must match&quot; # Compute centroids centroid_P = jnp.mean(P, axis=0) centroid_Q = jnp.mean(Q, axis=0) # Optimal translation t = centroid_Q - centroid_P # Center the points p = P - centroid_P q = Q - centroid_Q # Compute the covariance matrix H = jnp.dot(p.T, q) # SVD U, S, Vt = jnp.linalg.svd(H) # Validate right-handed coordinate system if jnp.linalg.det(jnp.dot(Vt.T, U.T)) &lt; 0.0: Vt[-1, :] *= -1.0 # Optimal rotation R = jnp.dot(Vt.T, U.T) # RMSD rmsd = jnp.sqrt(jnp.sum(jnp.square(jnp.dot(p, R.T) - q)) / P.shape[0]) return R, t, rmsd Rust实现Cargo.toml中添加依赖项nalgebra: 12[dependencies]nalgebra = &quot;0.31&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667use nalgebra::&#123;Matrix3, Vector3, DMatrix, SVD&#125;;/// Computes the optimal rotation and translation to align two sets of points (P -&gt; Q),/// and their RMSD.////// # Arguments////// * `P` - A Nx3 matrix of points/// * `Q` - A Nx3 matrix of points////// # Returns////// A tuple containing the optimal rotation matrix (Matrix3), /// the optimal translation vector (Vector3), and the RMSD (f64).fn kabsch_rust(P: &amp;DMatrix&lt;f64&gt;, Q: &amp;DMatrix&lt;f64&gt;) -&gt; (Matrix3&lt;f64&gt;, Vector3&lt;f64&gt;, f64) &#123; assert_eq!(P.ncols(), 3); assert_eq!(Q.ncols(), 3); assert_eq!(P.nrows(), Q.nrows()); let n = P.nrows(); // Compute centroids let centroid_P = P.column_mean(); let centroid_Q = Q.column_mean(); // Optimal translation let t = centroid_Q - centroid_P; // Center the points let p = P - centroid_P; let q = Q - centroid_Q; // Compute the covariance matrix let h = p.transpose() * q; // Perform SVD let svd = SVD::new(h, true, true); let u = svd.u.unwrap(); let v_t = svd.v_t.unwrap(); // Validate right-handed coordinate system let mut d = v_t.transpose() * u.transpose(); if d.determinant() &lt; 0.0 &#123; d[(2, 2)] *= -1.0; &#125; // Optimal rotation let r = v_t.transpose() * d * u.transpose(); // Compute RMSD let transformed_p = p * r.transpose(); let rmsd = ((transformed_p - q).norm_squared() / n as f64).sqrt(); (r, t, rmsd)&#125;fn main() &#123; // Example usage let p = DMatrix::from_row_slice(3, 3, &amp;[1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]); let q = DMatrix::from_row_slice(3, 3, &amp;[0.0, 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0]); let (rotation, translation, rmsd) = kabsch_rust(&amp;p, &amp;q); println!(&quot;Rotation matrix: &#123;&#125;&quot;, rotation); println!(&quot;Translation vector: &#123;&#125;&quot;, translation); println!(&quot;RMSD: &#123;&#125;&quot;, rmsd);&#125; 测试以乙醇为例，创建两个乙醇分子对象，进行对齐并计算RMSD。","tags":["Code","对齐","Graph","Kabsch算法"],"categories":["理论计算","深度学习","Code"]},{"title":"使用Py3Dmol创建分子轨迹","path":"/2024/07/19/py3dmol/","content":"本文为使用py3Dmol库创建一系列分子坐标（多帧）组成的分子轨迹，进行动态可视化的教程。 3Dmol.js3Dmol.js 是一个用于科学可视化的开源 JavaScript 库，特别是用于显示和操纵生物分子结构。支持多种文件格式，如 PDB（Protein Data Bank）文件、SDF（Structure-Data File）文件等，用于加载分子数据。利用 WebGL 技术，3Dmol.js 能够高效地渲染大型分子结构，提供流畅的用户体验。因此被广泛应用于生物信息学、药物设计和分子生物学等领域，用于研究和展示分子的三维结构和相互作用。 py3Dmol简单来说，py3Dmol 可以被视为 3Dmol.js 的 Python API。py3Dmol 是一个 Python 库，它提供了与 3Dmol.js 交互的接口，使得用户可以在 Python 环境中使用 3Dmol.js 的功能。py3Dmol 为需要在 Python 环境中进行分子可视化的用户提供了便利，使得 3Dmol.js 的强大功能可以更方便地应用于科学研究和数据分析。 有人可能会问为什么不直接使用 GUI 界面的软件，或者 ase 库中的 view 等，本教程主要是针对 Linux 中没有 GUI 的情况下对分子的快捷可视化。 对于分子的可视化，py3Dmol 是非常实用的，但 py3Dmol 中实现的接口功能并不多，并且没有文档支持，以至于我花费很长时间读 py3Dmol 的源码才搞清楚如何使用其进行分子轨迹的可视化ToT，为了防止大家踩坑所以出一个教程。 py3Dmol安装如果你还没有安装 py3Dmol（可能是废话，不然你也不会点进来），可以方便地直接通过 pip 安装。 1pip install py3Dmol 以及安装可能用到的 pymatgen 库。 1pip install pymatgen 可视化单个分子构象（示例）很简单的例子，如果你还没有用过 py3Dmol ，可以在 jupyter 中试一下。 1234567891011121314import py3Dmoldef draw_mol_xyz(file_path): # 读取一个 .xyz 文件进行可视化 with open(file_path, &#x27;r&#x27;) as fo: xyz = fo.read() view = py3Dmol.view(width=800, height=400) view.addModel(xyz, &#x27;xyz&#x27;) view.setStyle(&#123;&#x27;sphere&#x27;: &#123;&#x27;scale&#x27;: 0.35&#125;, &#x27;stick&#x27;: &#123;&#x27;radius&#x27;: 0.20&#125;&#125;) view.zoomTo() view.show()file_path = &#x27;.xyz&#x27; # 你的 .xyz 文件路径draw_mol_xyz(file_path) 运行结果如下： 可视化分子轨迹这里以生成苯环的多帧坐标轨迹为例。 首先读取分子的原子序数和坐标123456import py3Dmolfrom pymatgen.core.structure import Moleculecoords = [] # 输入你的多帧坐标，此处省略。# 使用 pymatgen 创建 Molecule对象以便于 .xyz 格式转换，此处我有100帧坐标因此创建100个对象。benzenes = [Molecule([&quot;C&quot;]*6 + [&#x27;H&#x27;]*6, coords[i]) for i in range(100)] coords: 轨迹坐标，维度为[frames, N, 3]，frames为帧数。 benzenes: Molecule对象列表，[frames, ] 也可以直接读取 .xyz 文件，或者用以下示例创建 Molecule 对象，但要保证原子序数的一致和对齐。 1mols = [Molecule(species=traj[&#x27;atomic_numbers&#x27;], coords=traj[&#x27;pos&#x27;]) for traj in trajs] 格式转换以及可视化123456789101112molecules = [mol.to(fmt=&quot;xyz&quot;) for mol in benzenes[-50:]] + [benzenes[-1].to(fmt=&quot;xyz&quot;)] * 20 # 最后一帧停顿models = &#x27;&#x27;view = py3Dmol.view(width=800, height=400)for i, mol in enumerate(molecules): models += mol + &#x27; &#x27;view.addModelsAsFrames(models) # 添加多帧 xyz 字符串view.setStyle(&#123;&#x27;sphere&#x27;: &#123;&#x27;scale&#x27;: 0.35&#125;, &#x27;stick&#x27;: &#123;&#x27;radius&#x27;: 0.20&#125;&#125;)view.zoomTo()view.animate(&#123;&#x27;loop&#x27;: &#x27;forward&#x27;&#125;) # animateview.show() 运行结果如下：","tags":["Py3Dmol","可视化","Code"],"categories":["理论计算"]},{"path":"/baidu_verify_codeva-fOeN3c9kUd.html","content":"62c00bc99c6f7854a54bf38ea02c9070"}]